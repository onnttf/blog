{"id":"D_kwDONzrbkM4AeLb6","title":"如何在 iOS 系统中读取带加密印章的 PDF 文件","body":"在与电子签章公司合作时，我们收到了一份带有加密印章的 `PDF` 文件。在测试过程中，无论通过 `UIWebView` 还是 `WKWebView` 打开，文件中的加密印章都无法成功展示。\r\n\r\n经过不断地调研与实践，我们成功解决了这一问题。现在将解决方案分享给大家。\r\n\r\n## 实现步骤\r\n\r\n### 准备工作\r\n\r\n首先，我们定义几个常用的宏，以便在后续代码中使用，提升代码的可读性和简洁性：\r\n\r\n```objc\r\n#define kScreenW [UIScreen mainScreen].bounds.size.width\r\n#define kScreenH [UIScreen mainScreen].bounds.size.height\r\n\r\n#define DOCUMENTS_DIRECTORY [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]\r\n```\r\n\r\n### 添加 WKWebView\r\n\r\n我们使用 `WKWebView` 来加载和展示 `PDF` 文件。\r\n\r\n```objc\r\n#import <WebKit/WebKit.h>\r\n\r\nWKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];\r\n\r\nWKUserContentController *wkUController = [[WKUserContentController alloc]init];\r\n\r\nconfig.userContentController = wkUController;\r\n\r\n// 注入 JS 对象，名称为 AppModel\r\n// 当 JS 通过 AppModel 来调用时，我们可以在 WKScriptMessageHandler 代理中接收到\r\n// 此处是为了得到PDF加载完成或失败的反馈\r\n[config.userContentController addScriptMessageHandler:self name:@\"AppModel\"];\r\n\r\n// 改变页面内容宽度，适配屏幕大小\r\nNSString *js = @\"var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);\";\r\n\r\nWKUserScript *wkUserScript = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];\r\n[wkUController addUserScript:wkUserScript];\r\n\r\nWKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kScreenH - 64) configuration:config];\r\nwebView.backgroundColor = [UIColor whiteColor];\r\nwebView.UIDelegate = self;\r\nwebView.navigationDelegate = self;\r\n[self.view addSubview:webView];\r\n```\r\n\r\n### 下载 PDF 文件\r\n\r\n```objc\r\nNSString *urlStr = @\"\";\r\n\r\nNSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlStr]];\r\nNSURLSession *session = [NSURLSession sharedSession];\r\n\r\nNSURLSessionDataTask *sessionDataTask = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\r\n    NSLog(@\"从服务器获取到 pdf 数据\");\r\n    //对从服务器获取到的数据 data 进行相应的处理：\r\n    dispatch_async(dispatch_get_main_queue(), ^{\r\n        NSString *path = [DOCUMENTS_DIRECTORY stringByAppendingPathComponent:@\"contract.pdf\"];\r\n        NSFileManager *fm = [NSFileManager defaultManager];\r\n        if ([fm fileExistsAtPath:path]) {\r\n            [fm removeItemAtPath:path error:nil];\r\n        }\r\n        BOOL success =  [data writeToFile:path atomically:YES];\r\n        if (success) {\r\n            NSLog(@\"保存成功\");\r\n            NSURL *baseURL = [NSURL fileURLWithPath:[self getHtmlBasePath]];\r\n            NSString *path = [self getHtmlPath];\r\n            NSString *htmlStr = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil];\r\n\r\n            [self.webView loadHTMLString:htmlStr baseURL:baseURL];\r\n        }\r\n    });\r\n}];\r\n[sessionDataTask resume];\r\n```\r\n\r\n### 加载 `PDF` 文件\r\n\r\n```objc\r\n- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {\r\n    [self loadPDF];\r\n}\r\n\r\n- (void)loadPDF {\r\n    NSString *path = [DOCUMENTS_DIRECTORY stringByAppendingPathComponent:@\"contract.pdf\"];\r\n    NSData *data = [NSData dataWithContentsOfFile:path options:NSDataReadingMappedAlways error:nil];\r\n\r\n    NSString *paraStr = [data base64EncodedStringWithOptions:NSDataBase64EncodingEndLineWithCarriageReturn];\r\n    NSString *js = [NSString stringWithFormat:@\"loadMyJS('%@')\",paraStr];\r\n\r\n    [self.webView evaluateJavaScript:js completionHandler:^(id _Nullable response, NSError * _Nullable error) {\r\n        if (error) {\r\n            NSLog(@\"%@\", error);\r\n            NSLog(@\"当前手机系统版本较低，不支持查看，请升级系统或者到 PC 端查看。\");\r\n        }\r\n    }];\r\n}\r\n```\r\n\r\n### 与 js 进行交互\r\n\r\n与 `js` 的交互主要是为了在控制器中获取 `PDF` 文件的加载状态。通过这种交互，我们能够实时感知 `PDF` 文件是否加载完成，或者在加载失败时处理错误提示。\r\n\r\n在 `js` 代码中，当 `PDF` 文件加载完成或失败时，调用已注册的接口将状态传递给原生代码。\r\n\r\n示例代码如下：\r\n\r\n```js\r\nfunction handlePages(page) {\r\n  //create new canvas\r\n  var viewport = page.getViewport(1);\r\n  var canvas = document.createElement(\"canvas\");\r\n  canvas.style.display = \"block\";\r\n\r\n  var context = canvas.getContext(\"2d\");\r\n  canvas.height = viewport.height;\r\n  canvas.width = viewport.width;\r\n\r\n  //render page\r\n  page.render({ canvasContext: context, viewport: viewport });\r\n\r\n  //add canvas to body\r\n  document.body.appendChild(canvas);\r\n\r\n  //render new page\r\n  pageNum++;\r\n  if (pdfDoc != null && pageNum <= numPages) {\r\n    pdfDoc.getPage(pageNum).then(handlePages);\r\n    // PDF 加载失败\r\n  } else {\r\n    console.log(\"pdf load complete\");\r\n    // PDF 加载完毕，body 的内容可以根据具体的业务需求进行修改\r\n    window.webkit.messageHandlers.AppModel.postMessage({\r\n      code: \"00000\",\r\n      msg: \"pdf load complete\",\r\n    }); //和 wkWebView 交互\r\n  }\r\n}\r\n```\r\n\r\n在原生代码中，通过实现 `WKScriptMessageHandler` 协议的方法接收 `js` 传递的消息并处理：\r\n\r\n```objc\r\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {\r\n    if ([message.name isEqualToString:@\"AppModel\"]) {\r\n        // 和 customview.js 文件交互，js 调 oc 的代码\r\n        // 打印所传过来的参数，只支持 NSNumber, NSString, NSDate, NSArray, NSDictionary, and NSNull 类型\r\n        if ([message.body[@\"code\"] isEqualToString:@\"00000\"]) {\r\n            NSLog(@\"%@\", message.body[@\"msg\"]);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 兼容 iOS8\r\n\r\n到此为止，我们已经成功在 `iOS9` 及以上的系统中打开带有加密印章的 `PDF` 文件。\r\n\r\n然而，在 `iOS8` 中，由于系统限制，`PDF` 文件无法正常加载。接下来，我们将详细说明原因并提供解决方案。\r\n\r\n### 原因分析\r\n\r\n在 `iOS9` 及以上版本，`WKWebView` 默认支持从 `NSBundle` 加载 `HTML`、`JS` 和其他静态资源。而在 `iOS8` 中，这些资源必须位于 `tmp` 目录或沙盒的其他可写路径中才能被访问。\r\n\r\n### 兼容方案\r\n\r\n为了解决上述问题，我们需要根据系统版本决定 `HTML` 和 `JS` 文件的存储位置。如果运行在 `iOS8` 上，我们将资源复制到 `tmp` 目录下；否则，直接从 `NSBundle` 加载。\r\n\r\n以下是完整的兼容方案代码：\r\n\r\n```objc\r\n- (NSString*)getHtmlBasePath {\r\n    NSString *basePath = @\"\";\r\n    if ([[[UIDevice currentDevice]systemVersion]floatValue]<9.0) {\r\n        basePath = NSTemporaryDirectory();\r\n    }else{\r\n        basePath = [[NSBundle mainBundle] bundlePath];\r\n    }\r\n    return basePath;\r\n}\r\n\r\n- (NSString*)getHtmlPath{\r\n    NSString *path = @\"\";\r\n    if ([[[UIDevice currentDevice]systemVersion] floatValue] < 9.0) {\r\n        path = [self copyHtmlToTemp];\r\n    } else {\r\n        path = [[NSBundle mainBundle] pathForResource:@\"index\" ofType:@\".html\"];\r\n    }\r\n    return path;\r\n}\r\n\r\n//在 iOS8 上，html 及 js 文件要放到 tmp 目录下才能正常访问，iOS9 及以上不用\r\n- (NSString*)copyHtmlToTemp {\r\n    NSString* htmlPath = [[NSBundle mainBundle] pathForResource:@\"index\" ofType:@\".html\"];\r\n    NSString *compatibilityJSPath = [[NSBundle mainBundle] pathForResource:@\"compatibility\" ofType:@\".js\"];\r\n    NSString *customviewJSPath = [[NSBundle mainBundle] pathForResource:@\"customview\" ofType:@\".js\"];\r\n    NSString *minimalCSSPath = [[NSBundle mainBundle] pathForResource:@\"minimal\" ofType:@\".css\"];\r\n    NSString *pdfJSPath = [[NSBundle mainBundle] pathForResource:@\"pdf\" ofType:@\".js\"];\r\n    NSString *pdfWorkerJSPath = [[NSBundle mainBundle] pathForResource:@\"pdf.worker\" ofType:@\".js\"];\r\n\r\n    NSString *tempPath = NSTemporaryDirectory();\r\n\r\n    NSString *htmlTempPath = [tempPath stringByAppendingPathComponent:@\"index.html\"];\r\n    NSString *compatibilityJSTempPath = [tempPath stringByAppendingPathComponent:@\"compatibility.js\"];\r\n    NSString *customviewJSTempPath = [tempPath stringByAppendingPathComponent:@\"customview.js\"];\r\n    NSString *minimalCSSTempPath = [tempPath stringByAppendingPathComponent:@\"minimal.css\"];\r\n    NSString *pdfJSTempPath = [tempPath stringByAppendingPathComponent:@\"pdf.js\"];\r\n    NSString *pdfWorkerJSTempPath = [tempPath stringByAppendingPathComponent:@\"pdf.worker.js\"];\r\n\r\n    NSFileManager *fm = [NSFileManager defaultManager];\r\n\r\n    if (![fm fileExistsAtPath:htmlTempPath]) {\r\n        [fm copyItemAtPath:htmlPath toPath:htmlTempPath error:nil];\r\n    }\r\n    if (![fm fileExistsAtPath:compatibilityJSTempPath]) {\r\n        [fm copyItemAtPath:compatibilityJSPath toPath:compatibilityJSTempPath error:nil];\r\n    }\r\n    if (![fm fileExistsAtPath:customviewJSTempPath]) {\r\n        [fm copyItemAtPath:customviewJSPath toPath:customviewJSTempPath error:nil];\r\n    }\r\n    if (![fm fileExistsAtPath:minimalCSSTempPath]) {\r\n        [fm copyItemAtPath:minimalCSSPath toPath:minimalCSSTempPath error:nil];\r\n    }\r\n    if (![fm fileExistsAtPath:pdfJSTempPath]) {\r\n        [fm copyItemAtPath:pdfJSPath toPath:pdfJSTempPath error:nil];\r\n    }\r\n    if (![fm fileExistsAtPath:pdfWorkerJSTempPath]) {\r\n        [fm copyItemAtPath:pdfWorkerJSPath toPath:pdfWorkerJSTempPath error:nil];\r\n    }\r\n    return htmlTempPath;\r\n}\r\n```\r\n\r\n## 最后\r\n\r\n通过文中所述的方案，无论用户是在 `iOS8` 还是更新版本的系统中，都可以顺利打开带有加密印章的 `PDF` 文件了。\r\n","number":2,"labels":{"nodes":[{"id":"LA_kwDONzrbkM8AAAAB4nYwyw","name":"iOS","url":"https://github.com/onnttf/blog/labels/iOS"}]},"category":{"id":"DIC_kwDONzrbkM4Cmnbf","name":"Show and tell","slug":"show-and-tell","emoji":":raised_hands:","emojiHTML":"<div>🙌</div>"},"author":{"login":"onnttf"},"authorAssociation":"OWNER","createdAt":"2017-08-29T08:00:00Z","updatedAt":"2025-02-03T15:26:17Z","repository":{"id":"R_kgDONzrbkA","url":"https://github.com/onnttf/blog"},"url":"https://github.com/onnttf/blog/discussions/2","jsonFilePath":"discussions/2-D_kwDONzrbkM4AeLb6.json","markdownFilePath":"2017/8/2-D_kwDONzrbkM4AeLb6.md"}
