{"id":"D_kwDONzrbkM4AeLcj","title":"如何监听 UIScrollView 停止滚动","body":"在开发过程中，监听 `UIScrollView` 的停止滚动是一个常见需求。我们可能需要在停止滚动时执行以下操作：\r\n\r\n- 图片的按需加载与预加载\r\n- 列表数据的异步预加载\r\n- 滚动结束动画效果\r\n- 性能优化与资源释放\r\n- 数据统计与埋点\r\n\r\n虽然苹果没有直接提供相应的回调方法，但本文将介绍如何通过 `Runtime` 实现一个简单易用且低侵入性的监听方案。\r\n\r\n## Runtime\r\n\r\n[Runtime](https://developer.apple.com/documentation/objectivec/objective_c_runtime) 提供了在运行时动态修改类、方法和消息传递的能力。通过 `Runtime`，我们可以：\r\n\r\n- 在运行时动态修改方法实现\r\n- 为已有类添加新的方法和属性\r\n- 实现更灵活的消息转发机制\r\n\r\n本文将结合实际场景，详细介绍如何运用 `Runtime` 的 `Method Swizzling` 实现一个监听 `UIScrollView` 停止滚动的方案。\r\n\r\n相比传统方案，具有以下优势：\r\n\r\n- 使用简单，接入成本低\r\n- 代码侵入性小，易于维护\r\n- 运行时性能开销小\r\n- 具备良好的扩展性\r\n\r\n## UIScrollView 停止滚动的场景分析\r\n\r\n基于大量用户交互数据分析，停止滚动主要可以归纳为以下三种情况：\r\n\r\n1. 快速滑动后的惯性停止\r\n\r\n   - 用户快速滑动后松开手指\r\n   - `ScrollView` 根据滑动速度进行减速\r\n   - 在物理引擎作用下自然停止\r\n   - 常见于快速浏览长列表场景\r\n\r\n2. 交互式强制停止\r\n\r\n   - 用户在惯性滚动过程中\r\n   - 通过按压屏幕进行制动\r\n   - 立即终止当前滚动状态\r\n   - 多用于紧急停止或位置调整\r\n\r\n3. 精确式缓慢停止\r\n\r\n   - 用户通过缓慢拖动内容\r\n   - 精确控制内容偏移量\r\n   - 在目标位置直接松手\r\n   - 适用于精确定位需求\r\n\r\n## 核心代理方法与实现思路\r\n\r\n为了准确捕获这些停止事件，我们需要合理运用以下代理方法：\r\n\r\n```objc\r\n// 即将开始减速滚动\r\n- (void)scrollViewWillBeginDecelerating:(UIScrollView *)scrollView;\r\n\r\n// 滚动减速结束\r\n- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;\r\n\r\n// 拖拽结束，decelerate 表示是否将要进入减速过程\r\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;\r\n```\r\n\r\n通过这些代理方法的组合调用，我们可以实现对每种停止事件的精确识别。\r\n\r\n## Runtime 方案实现详解\r\n\r\n通过 `Runtime` 实现 `UIScrollView` 停止滚动的监听，本节将详细介绍这套方案的具体实现细节。\r\n\r\n`UIScrollView` 为我们提供了三个状态，通过它们我们可以精确判断滚动视图的当前状态：\r\n\r\n```objc\r\n@property(nonatomic,readonly,getter=isTracking) BOOL tracking;     // 手指是否触摸屏幕\r\n@property(nonatomic,readonly,getter=isDragging) BOOL dragging;     // 是否正在拖拽滑动\r\n@property(nonatomic,readonly,getter=isDecelerating) BOOL decelerating;  // 是否在减速过程中\r\n```\r\n\r\n### 监听停止滚动的核心逻辑\r\n\r\n通过组合 `tracking`、`dragging` 和 `decelerating` 这三个状态，我们可以准确识别 `UIScrollView` 停止滚动的时机。具体判断逻辑如下：\r\n\r\n```objc\r\n- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView {\r\n    // 判断减速停止：手指未触摸 + 未拖拽 + 未减速\r\n    BOOL scrollToScrollStop = !scrollView.tracking && !scrollView.dragging && !scrollView.decelerating;\r\n    if (scrollToScrollStop) {\r\n        [self scrollViewDidEndScroll];\r\n    }\r\n}\r\n\r\n- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {\r\n    if (!decelerate) {\r\n        // 判断拖拽停止：手指触摸 + 未拖拽 + 未减速\r\n        BOOL dragToDragStop = scrollView.tracking && !scrollView.dragging && !scrollView.decelerating;\r\n        if (dragToDragStop) {\r\n            [self scrollViewDidEndScroll];\r\n        }\r\n    }\r\n}\r\n\r\n- (void)scrollViewDidEndScroll {\r\n    NSLog(@\"停止滚动触发！！！\");\r\n}\r\n```\r\n\r\n### 添加停止滚动的回调\r\n\r\n1. 封装健壮的 `Hook` 工具方法\r\n\r\n   ```objc\r\n   static void Hook_Method(Class originalClass, SEL originalSel,\r\n                         Class replacedClass, SEL replacedSel, SEL noneSel) {\r\n       // 获取原始方法\r\n       Method originalMethod = class_getInstanceMethod(originalClass, originalSel);\r\n       Method replacedMethod = class_getInstanceMethod(replacedClass, replacedSel);\r\n\r\n       // 处理原始方法不存在的情况\r\n       if (!originalMethod) {\r\n           Method noneMethod = class_getInstanceMethod(replacedClass, noneSel);\r\n           class_addMethod(originalClass, originalSel,\r\n                         method_getImplementation(noneMethod),\r\n                         method_getTypeEncoding(noneMethod));\r\n           return;\r\n       }\r\n\r\n       // 添加替换方法\r\n       BOOL addMethod = class_addMethod(originalClass, replacedSel,\r\n                                      method_getImplementation(replacedMethod),\r\n                                      method_getTypeEncoding(replacedMethod));\r\n\r\n       // 交换方法实现\r\n       if (addMethod) {\r\n           Method newMethod = class_getInstanceMethod(originalClass, replacedSel);\r\n           method_exchangeImplementations(originalMethod, newMethod);\r\n       }\r\n   }\r\n   ```\r\n\r\n2. 对 `UIScrollView` 的代理方法进行替换\r\n\r\n   ```objc\r\n   + (void)load {\r\n       static dispatch_once_t onceToken;\r\n       dispatch_once(&onceToken, ^{\r\n           // 确保方法替换只执行一次\r\n           Method originalMethod = class_getInstanceMethod([UIScrollView class], @selector(setDelegate:));\r\n           Method replaceMethod = class_getInstanceMethod([UIScrollView class], @selector(hook_setDelegate:));\r\n           method_exchangeImplementations(originalMethod, replaceMethod);\r\n       });\r\n   }\r\n\r\n   // 替换 setDelegate 方法，注入自定义逻辑\r\n   - (void)hook_setDelegate:(id<UIScrollViewDelegate>)delegate {\r\n       // 调用原始 setDelegate 方法（通过方法交换实现）\r\n       [self hook_setDelegate:delegate];\r\n\r\n       // 仅对 UIScrollView 实例进行方法注入\r\n       if ([self isMemberOfClass:[UIScrollView class]]) {\r\n           NSLog(@\"是 UIScrollView，注入自定义逻辑\");\r\n\r\n           // Hook scrollViewDidEndDecelerating: 方法\r\n           Hook_Method(\r\n               [delegate class],\r\n               @selector(scrollViewDidEndDecelerating:),\r\n               [self class],\r\n               @selector(p_scrollViewDidEndDecelerating:),\r\n               @selector(add_scrollViewDidEndDecelerating:)\r\n           );\r\n\r\n           // Hook scrollViewDidEndDragging:willDecelerate: 方法\r\n           Hook_Method(\r\n               [delegate class],\r\n               @selector(scrollViewDidEndDragging:willDecelerate:),\r\n               [self class],\r\n               @selector(p_scrollViewDidEndDragging:willDecelerate:),\r\n               @selector(add_scrollViewDidEndDragging:willDecelerate:)\r\n           );\r\n       } else {\r\n           NSLog(@\"不是 UIScrollView，跳过注入逻辑\");\r\n       }\r\n   }\r\n\r\n   #pragma mark - Replace Method\r\n\r\n   // 替换 scrollViewDidEndDecelerating: 方法\r\n   - (void)p_scrollViewDidEndDecelerating:(UIScrollView *)scrollView {\r\n       NSLog(@\"%s\", __func__);\r\n\r\n       // 调用原始方法\r\n       [self p_scrollViewDidEndDecelerating:scrollView];\r\n\r\n       // 判断减速停止：手指未触摸 + 未拖拽 + 未减速\r\n       BOOL scrollToScrollStop = !scrollView.tracking && !scrollView.dragging && !scrollView.decelerating;\r\n       if (scrollToScrollStop) {\r\n           [self stopScroll:scrollView];\r\n       }\r\n   }\r\n\r\n   // 替换 scrollViewDidEndDragging:willDecelerate: 方法\r\n   - (void)p_scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {\r\n       NSLog(@\"%s\", __func__);\r\n\r\n       // 调用原始方法\r\n       [self p_scrollViewDidEndDragging:scrollView willDecelerate:decelerate];\r\n\r\n       if (!decelerate) {\r\n           // 判断拖拽停止：手指触摸 + 未拖拽 + 未减速\r\n           BOOL dragToDragStop = scrollView.tracking && !scrollView.dragging && !scrollView.decelerating;\r\n           if (dragToDragStop) {\r\n               [self stopScroll:scrollView];\r\n           }\r\n       }\r\n   }\r\n\r\n   #pragma mark - Add Method\r\n\r\n   // 实现 scrollViewDidEndDecelerating: 方法\r\n   - (void)add_scrollViewDidEndDecelerating:(UIScrollView *)scrollView {\r\n       NSLog(@\"%s\", __func__);\r\n\r\n       // 判断减速停止：手指未触摸 + 未拖拽 + 未减速\r\n       BOOL scrollToScrollStop = !scrollView.tracking && !scrollView.dragging && !scrollView.decelerating;\r\n       if (scrollToScrollStop) {\r\n           [self stopScroll:scrollView];\r\n       }\r\n   }\r\n\r\n   // 实现 scrollViewDidEndDragging:willDecelerate: 方法\r\n   - (void)add_scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate {\r\n       NSLog(@\"%s\", __func__);\r\n\r\n       if (!decelerate) {\r\n           // 判断拖拽停止：手指触摸 + 未拖拽 + 未减速\r\n           BOOL dragToDragStop = scrollView.tracking && !scrollView.dragging && !scrollView.decelerating;\r\n           if (dragToDragStop) {\r\n               [self stopScroll:scrollView];\r\n           }\r\n       }\r\n   }\r\n\r\n   #pragma mark - 停止滚动的处理逻辑\r\n\r\n   // 停止滚动时执行的统一处理逻辑\r\n   - (void)stopScroll:(UIScrollView *)scrollView {\r\n       NSLog(@\"滚动停止事件触发，执行自定义逻辑\");\r\n       // 在此添加停止滚动时的处理代码，例如通知或回调\r\n   }\r\n   ```\r\n\r\n3. 添加停止滚动的回调\r\n\r\n   ```objc\r\n   // 定义回调 block 类型\r\n   typedef void(^ScrollStopBlock)(UIScrollView *scrollView);\r\n\r\n   // 定义回调属性\r\n   @property (nonatomic, copy, nullable) ScrollStopBlock stopScrollBlock;\r\n\r\n   // 统一的停止回调方法\r\n   - (void)stopScroll:(UIScrollView *)scrollView {\r\n       if (self.stopScrollBlock) {\r\n           // 确保回调在主线程执行\r\n           dispatch_async(dispatch_get_main_queue(), ^{\r\n               self.stopScrollBlock(scrollView);\r\n           });\r\n       }\r\n   }\r\n   ```\r\n\r\n### 使用方式\r\n\r\n经过上述封装，我们现在可以通过一种简洁的方式来监听滚动停止事件。下面通过一个完整而实用的示例来展示具体用法：\r\n\r\n```objc\r\n// 1. 创建并配置 ScrollView\r\nUIScrollView *scrollView = [[UIScrollView alloc] init];\r\nscrollView.frame = self.view.bounds;\r\nscrollView.delegate = self;\r\n[self.view addSubview:scrollView];\r\n\r\n// 2. 配置滚动内容\r\nUIView *contentView = [[UIView alloc] init];\r\n// 设置内容视图宽度为屏幕宽度的3倍，便于横向滚动\r\ncontentView.frame = CGRectMake(0, 0, self.view.bounds.size.width * 3, self.view.bounds.size.height);\r\n[scrollView addSubview:contentView];\r\nscrollView.contentSize = contentView.frame.size;\r\n\r\n// 3. 添加业务处理回调\r\nscrollView.stopScrollBlock = ^(UIScrollView *scrollView) {\r\n    // 在这里处理停止滚动后的业务逻辑\r\n    NSLog(@\"ScrollView停止滚动 - 当前偏移量: %@\", NSStringFromCGPoint(scrollView.contentOffset));\r\n};\r\n```\r\n\r\n通过以上简洁的配置，我们就实现了一个功能完备的滚动停止事件监听方案。这种实现方式具有以下显著优势：\r\n\r\n1. **使用便捷**: 仅需设置一个 block 回调即可完成所有功能\r\n2. **功能全面**: 自动处理拖拽停止、减速停止等多种滚动场景\r\n3. **解耦设计**: 将滚动检测与业务逻辑完全分离\r\n4. **易于维护**: 核心逻辑已封装，开发者只需关注业务实现\r\n5. **扩展性强**: 可以方便地添加更多自定义处理逻辑\r\n\r\n通过这种方式，开发者无需关心具体的停止滚动实现细节，可以将精力完全集中在业务逻辑开发上。\r\n\r\n## 最后\r\n\r\n本文详细介绍了如何通过 `Runtime` 实现一个监听 `UIScrollView` 停止滚动的方案。这种方式具有以下优势：\r\n\r\n- 代码侵入性低，无需修改现有业务逻辑\r\n- 使用方便直观，只需设置一个 `block` 回调\r\n- 性能影响小，运行时开销可控\r\n- 扩展性强，易于添加新功能\r\n\r\n你在实际开发中是否遇到过类似的需求？欢迎在评论区分享你的经验和解决方案？\r\n","number":8,"labels":{"nodes":[{"id":"LA_kwDONzrbkM8AAAAB4nYwyw","name":"iOS","url":"https://github.com/onnttf/blog/labels/iOS"}]},"category":{"id":"DIC_kwDONzrbkM4Cmnbf","name":"Show and tell","slug":"show-and-tell","emoji":":raised_hands:","emojiHTML":"<div>🙌</div>"},"author":{"login":"onnttf"},"authorAssociation":"OWNER","createdAt":"2018-01-14T08:00:00Z","updatedAt":"2025-02-03T15:35:16Z","repository":{"id":"R_kgDONzrbkA","url":"https://github.com/onnttf/blog"},"url":"https://github.com/onnttf/blog/discussions/8","jsonFilePath":"discussions/8-D_kwDONzrbkM4AeLcj.json","markdownFilePath":"2018/1/8-D_kwDONzrbkM4AeLcj.md"}
