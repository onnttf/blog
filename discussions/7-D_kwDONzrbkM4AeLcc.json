{"id":"D_kwDONzrbkM4AeLcc","title":"WKWebView 实战指南","body":"`WKWebView` 是苹果提供的现代化网页浏览控件，用于在 `iOS` 应用中展示网页内容。它从 `iOS 8` 开始支持使用。\r\n\r\n## 为什么选择 `WKWebView`\r\n\r\n相比于传统的 `UIWebView`，`WKWebView` 具有以下显著优势：\r\n\r\n1. 卓越的性能表现和稳定性\r\n2. 显著降低内存占用\r\n3. 完整支持现代 `HTML5` 特性\r\n4. 流畅的 `60fps` 渲染和原生手势支持\r\n5. 丰富的代理方法，提供更强大的控制能力\r\n6. 支持进程间通信，更安全可靠\r\n\r\n更多技术细节可以查看 [WebKit 官方文档](https://developer.apple.com/documentation/webkit)\r\n\r\n## 基本使用\r\n\r\n### 引入框架\r\n\r\n首先需要导入 `WebKit` 框架：\r\n\r\n```objc\r\n#import <WebKit/WebKit.h>\r\n```\r\n\r\n### 创建和配置 WKWebView\r\n\r\n```objc\r\n// 创建 WKUserContentController 用于 JS 交互\r\nWKUserContentController *userContentController = [[WKUserContentController alloc] init];\r\n\r\n// 注入 cookies\r\nNSString *js = @\"document.cookie='user=zhangpeng'\";\r\nWKUserScript *cookieScript = [[WKUserScript alloc] initWithSource:js\r\n                                                    injectionTime:WKUserScriptInjectionTimeAtDocumentStart\r\n                                                 forMainFrameOnly:NO];\r\n[userContentController addUserScript:cookieScript];\r\n\r\n// 配置 WKWebView\r\nWKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init];\r\nconfig.userContentController = userContentController;\r\n_config = config;\r\n\r\n// 注册 JS 调用处理器\r\nfor (NSString *scriptMessage in self.scriptMessages) {\r\n    [config.userContentController addScriptMessageHandler:self name:scriptMessage];\r\n}\r\n\r\n// 创建 WKWebView 实例\r\nWKWebView *webView = [[WKWebView alloc] initWithFrame:CGRectMake(0, 0, kScreenW, kMainAreaHeightNoTab)\r\n                                        configuration:config];\r\nwebView.UIDelegate = self;        // UI 交互代理\r\nwebView.navigationDelegate = self; // 导航代理\r\n[self.view addSubview:webView];\r\n_webView = webView;\r\n```\r\n\r\n## 代理方法\r\n\r\n### WKNavigationDelegate\r\n\r\n`WKNavigationDelegate` 提供页面加载生命周期的回调方法：\r\n\r\n```objc\r\n// 1. 决定是否允许导航\r\n- (void)webView:(WKWebView *)webView\r\ndecidePolicyForNavigationAction:(WKNavigationAction *)navigationAction\r\n  decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {\r\n    NSLog(@\"%s\", __func__);\r\n    decisionHandler(WKNavigationActionPolicyAllow); // 允许导航\r\n}\r\n\r\n// 2. 开始加载\r\n- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(WKNavigation *)navigation {\r\n    NSLog(@\"%s\", __func__);\r\n}\r\n\r\n// 3. 收到响应后决定是否继续\r\n- (void)webView:(WKWebView *)webView\r\ndecidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse\r\n   decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler {\r\n    NSLog(@\"%s\", __func__);\r\n    decisionHandler(WKNavigationResponsePolicyAllow); // 允许继续加载\r\n}\r\n\r\n// 4. 开始接收内容\r\n- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation {\r\n    NSLog(@\"%s\", __func__);\r\n}\r\n\r\n// 5. 加载完成\r\n- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation {\r\n    NSLog(@\"%s\", __func__);\r\n}\r\n\r\n// 6. 加载失败\r\n- (void)webView:(WKWebView *)webView\r\ndidFailNavigation:(WKNavigation *)navigation\r\n       withError:(NSError *)error {\r\n    NSLog(@\"%s\", __func__);\r\n}\r\n\r\n// 7. 加载内容失败\r\n- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(WKNavigation *)navigation {\r\n    NSLog(@\"%s\", __func__);\r\n}\r\n```\r\n\r\n其他重要的代理方法：\r\n\r\n```objc\r\n// 处理重定向\r\n- (void)webView:(WKWebView *)webView\r\ndidReceiveServerRedirectForProvisionalNavigation:(WKNavigation *)navigation {\r\n    NSLog(@\"%s\", __func__);\r\n}\r\n\r\n// 处理 SSL 证书认证\r\n- (void)webView:(WKWebView *)webView\r\ndidReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge\r\ncompletionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler {\r\n    NSLog(@\"%s\", __func__);\r\n    // 创建凭证并信任服务器证书\r\n    NSURLCredential *credential = [[NSURLCredential alloc] initWithTrust:challenge.protectionSpace.serverTrust];\r\n    completionHandler(NSURLSessionAuthChallengeUseCredential, credential); // 使用凭证继续认证\r\n}\r\n\r\n// 进程终止处理\r\n- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView {\r\n    NSLog(@\"%s\", __func__);\r\n}\r\n```\r\n\r\n### WKUIDelegate\r\n\r\n`WKUIDelegate` 主要用于处理 `JavaScript` 的 `UI` 交互，最常用的是 `alert` 弹窗：\r\n\r\n```objc\r\n// 处理 JavaScript 弹窗警告\r\n- (void)webView:(WKWebView *)webView\r\nrunJavaScriptAlertPanelWithMessage:(NSString *)message\r\ninitiatedByFrame:(WKFrameInfo *)frame\r\ncompletionHandler:(void (^)(void))completionHandler {\r\n    // 创建警告弹窗\r\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@\"提示\"\r\n                                                                   message:message\r\n                                                            preferredStyle:UIAlertControllerStyleAlert];\r\n\r\n    // 添加确定按钮\r\n    UIAlertAction *action = [UIAlertAction actionWithTitle:@\"确定\"\r\n                                                     style:UIAlertActionStyleDefault\r\n                                                   handler:nil];\r\n    [alert addAction:action];\r\n\r\n    // 显示弹窗\r\n    [self presentViewController:alert animated:YES completion:nil];\r\n\r\n    // 调用完成处理\r\n    completionHandler();\r\n}\r\n```\r\n\r\n还有两个用于处理确认框和输入框的方法：\r\n\r\n```objc\r\n// 处理 JavaScript 确认框\r\n- (void)webView:(WKWebView *)webView\r\nrunJavaScriptConfirmPanelWithMessage:(NSString *)message\r\ninitiatedByFrame:(WKFrameInfo *)frame\r\ncompletionHandler:(void (^)(BOOL result))completionHandler {\r\n    // 显示确认框\r\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@\"确认\"\r\n                                                                   message:message\r\n                                                            preferredStyle:UIAlertControllerStyleAlert];\r\n\r\n    // 确定按钮\r\n    UIAlertAction *confirmAction = [UIAlertAction actionWithTitle:@\"确定\"\r\n                                                           style:UIAlertActionStyleDefault\r\n                                                         handler:^(UIAlertAction * _Nonnull action) {\r\n                                                             completionHandler(YES); // 确定时返回 YES\r\n                                                         }];\r\n\r\n    // 取消按钮\r\n    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@\"取消\"\r\n                                                          style:UIAlertActionStyleCancel\r\n                                                        handler:^(UIAlertAction * _Nonnull action) {\r\n                                                            completionHandler(NO); // 取消时返回 NO\r\n                                                        }];\r\n\r\n    [alert addAction:confirmAction];\r\n    [alert addAction:cancelAction];\r\n\r\n    // 显示弹窗\r\n    [self presentViewController:alert animated:YES completion:nil];\r\n}\r\n\r\n// 处理 JavaScript 输入框\r\n- (void)webView:(WKWebView *)webView\r\nrunJavaScriptTextInputPanelWithPrompt:(NSString *)prompt\r\ndefaultText:(nullable NSString *)defaultText\r\ninitiatedByFrame:(WKFrameInfo *)frame\r\ncompletionHandler:(void (^)(NSString * _Nullable result))completionHandler {\r\n    // 创建输入框弹窗\r\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil\r\n                                                                   message:prompt\r\n                                                            preferredStyle:UIAlertControllerStyleAlert];\r\n\r\n    // 添加文本输入框\r\n    [alert addTextFieldWithConfigurationHandler:^(UITextField * _Nonnull textField) {\r\n        textField.text = defaultText; // 设置默认文本\r\n    }];\r\n\r\n    // 确定按钮\r\n    UIAlertAction *confirmAction = [UIAlertAction actionWithTitle:@\"确定\"\r\n                                                           style:UIAlertActionStyleDefault\r\n                                                         handler:^(UIAlertAction * _Nonnull action) {\r\n                                                             // 返回输入的文本\r\n                                                             completionHandler(alert.textFields.firstObject.text);\r\n                                                         }];\r\n\r\n    // 取消按钮\r\n    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@\"取消\"\r\n                                                          style:UIAlertActionStyleCancel\r\n                                                        handler:^(UIAlertAction * _Nonnull action) {\r\n                                                            // 取消时返回 nil\r\n                                                            completionHandler(nil);\r\n                                                        }];\r\n\r\n    [alert addAction:confirmAction];\r\n    [alert addAction:cancelAction];\r\n\r\n    // 显示弹窗\r\n    [self presentViewController:alert animated:YES completion:nil];\r\n}\r\n```\r\n\r\n## JavaScript 交互\r\n\r\n`WKWebView` 提供两种与 `JavaScript` 交互的方式。\r\n\r\n### MessageHandler 方式\r\n\r\n通过 `WKScriptMessageHandler` 接收 `JavaScript` 消息：\r\n\r\n```objc\r\n- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {\r\n    // 处理JS传来的消息\r\n    // 通过查看 `WKScriptMessage`，可以看到 `name` 和 `body` 两个属性，`name` 就是注入的 `js` 对象名称，`body` 就是前端传给我们的参数\r\n    if ([message.name isEqualToString:@\"test1\"]) {\r\n        NSLog(@\"收到test1消息：%@\", message.body);\r\n    } else if ([message.name isEqualToString:@\"test2\"]) {\r\n        NSLog(@\"收到test2消息：%@\", message.body);\r\n    }\r\n}\r\n```\r\n\r\n`JavaScript` 调用示例：\r\n\r\n```javascript\r\nwindow.webkit.messageHandlers.test1.postMessage({ data: \"Hello\" });\r\n```\r\n\r\n### URL Schema 方式\r\n\r\n通过拦截导航请求来处理自定义 `URL`：\r\n\r\n```objc\r\n- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {\r\n    NSURL *url = navigationAction.request.URL;\r\n    if ([url.scheme isEqualToString:@\"myapp\"]) {\r\n        // 处理自定义URL\r\n        decisionHandler(WKNavigationActionPolicyCancel);\r\n        return;\r\n    }\r\n    decisionHandler(WKNavigationActionPolicyAllow);\r\n}\r\n```\r\n\r\n## 注意事项\r\n\r\n### Cookie 处理\r\n\r\n`WKWebView` 的 `Cookie` 需要同时处理两个方面：\r\n\r\n1. `JavaScript` 侧：通过注入脚本设置\r\n\r\n   ```objc\r\n   NSString *js = @\"document.cookie='key=value'\";\r\n   WKUserScript *script = [[WKUserScript alloc] initWithSource:js injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];\r\n   [userContentController addUserScript:script];\r\n   ```\r\n\r\n2. `Native` 请求：添加 `Cookie` 头\r\n\r\n   ```objc\r\n   NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url];\r\n   [request setValue:@\"key=value\" forHTTPHeaderField:@\"Cookie\"];\r\n   [webView loadRequest:request];\r\n   ```\r\n\r\n需要注意 `Cookie` 注入的两种方式有不同的作用范围：\r\n\r\n1. `JavaScript` 注入的 `Cookie`:\r\n\r\n   - 可以通过 `document.cookie` 在 `JavaScript` 中读取\r\n   - 在浏览器开发者工具中可以看到\r\n   - 服务端代码 (如 `PHP`) 无法直接读取\r\n\r\n2. `NSMutableURLRequest` 注入的 `Cookie`:\r\n\r\n   - 可以被服务端代码 (如 `PHP` 的 `$_COOKIE`) 直接读取\r\n   - `JavaScript` 无法通过 `document.cookie` 访问\r\n   - 在浏览器开发者工具中不可见\r\n\r\n因此在实际开发中，需要根据具体使用场景选择合适的注入方式。如果需要同时支持前端和后端访问，则需要同时使用这两种方式注入 `Cookie`。\r\n\r\n### 内存泄漏问题\r\n\r\n`WKWebView` 可能造成循环引用导致内存泄漏，解决方案：\r\n\r\n1. 创建弱引用代理类：\r\n\r\n   ```objc\r\n   @interface WeakScriptMessageDelegate : NSObject\r\n   @property (nonatomic, weak) id<WKScriptMessageHandler> scriptDelegate;\r\n   @end\r\n   ```\r\n\r\n2. 使用弱引用代理注册消息处理：\r\n\r\n   ```objc\r\n   [config.userContentController addScriptMessageHandler:[[WeakScriptMessageDelegate alloc] initWithDelegate:self] name:scriptMessage];\r\n   ```\r\n\r\n3. 在 dealloc 中移除消息处理：\r\n\r\n   ```objc\r\n   [self.config.userContentController removeScriptMessageHandlerForName:scriptMessage];\r\n   ```\r\n\r\n## 最后\r\n\r\n通过本文，我们详细介绍了 `WKWebView` 的以下几个重要方面：\r\n\r\n1. 基本使用方法和配置选项\r\n2. 代理回调的完整生命周期\r\n3. `JavaScript` 交互的两种实现方式\r\n4. `Cookie` 处理的注意事项\r\n5. 内存管理的最佳实践\r\n\r\n`WKWebView` 作为 `iOS` 现代化的 `Web` 容器，具有性能优越、功能丰富的特点。合理使用其提供的各项功能，可以帮助我们构建高质量的 `Web` 混合应用。\r\n","number":7,"labels":{"nodes":[{"id":"LA_kwDONzrbkM8AAAAB4nYwyw","name":"iOS","url":"https://github.com/onnttf/blog/labels/iOS"}]},"category":{"id":"DIC_kwDONzrbkM4Cmnbf","name":"Show and tell","slug":"show-and-tell","emoji":":raised_hands:","emojiHTML":"<div>🙌</div>"},"author":{"login":"onnttf"},"authorAssociation":"OWNER","createdAt":"2017-12-03T08:00:00Z","updatedAt":"2025-02-03T15:33:22Z","repository":{"id":"R_kgDONzrbkA","url":"https://github.com/onnttf/blog"},"url":"https://github.com/onnttf/blog/discussions/7","jsonFilePath":"discussions/7-D_kwDONzrbkM4AeLcc.json","markdownFilePath":"2017/12/7-D_kwDONzrbkM4AeLcc.md"}
