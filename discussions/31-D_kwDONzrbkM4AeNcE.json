{"id":"D_kwDONzrbkM4AeNcE","title":"æŒæ¡ä¹¦ç­¾æ–‡ä»¶ï¼šé«˜æ•ˆç®¡ç†æ”¶è—","body":"ç½‘ç»œæµè§ˆæ—©å·²æˆä¸ºæˆ‘ä»¬æ—¥å¸¸ç”Ÿæ´»ä¸­ä¸å¯æˆ–ç¼ºçš„ä¸€éƒ¨åˆ†ã€‚é¢å¯¹æµ©å¦‚çƒŸæµ·çš„ç½‘é¡µä¿¡æ¯ï¼Œå¦‚ä½•æœ‰æ•ˆåœ°ç®¡ç†å’Œæ£€ç´¢æˆä¸ºä¸€ä¸ªé‡è¦è¯¾é¢˜ã€‚å¹¸è¿çš„æ˜¯ï¼Œç°ä»£æµè§ˆå™¨éƒ½æä¾›äº†å¼ºå¤§çš„\"ä¹¦ç­¾\"åŠŸèƒ½æ¥å¸®åŠ©æˆ‘ä»¬è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æœ¬æ–‡å°†æ·±å…¥å‰–ææµè§ˆå™¨ä¹¦ç­¾æ–‡ä»¶çš„ç»“æ„ï¼Œå¸®åŠ©æ‚¨æ›´å¥½åœ°æŒæ¡å’Œè¿ç”¨è¿™ä¸€å®ç”¨å·¥å…·ã€‚\r\n\r\n## ä¹¦ç­¾æ–‡ä»¶çš„æ ¼å¼\r\n\r\nä¹¦ç­¾æ–‡ä»¶æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªç»“æ„åŒ–çš„ `HTML` æ–‡æœ¬æ–‡ä»¶ï¼Œå®ƒè®°å½•äº†æ‚¨åœ¨æµè§ˆå™¨ä¸­ä¿å­˜çš„æ‰€æœ‰ç½‘å€ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ ‡é¢˜ã€`URL`ã€æ·»åŠ æ—¶é—´ç­‰å…³é”®æ•°æ®ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªå…¸å‹çš„ä¹¦ç­¾æ–‡ä»¶ç¤ºä¾‹ï¼š\r\n\r\n```html\r\n<!DOCTYPE NETSCAPE-Bookmark-file-1>\r\n<!-- This is an automatically generated file. -->\r\n<DL><p>\r\n    <DT><H3 ADD_DATE=\"1634454000\" LAST_MODIFIED=\"1634454200\" PERSONAL_TOOLBAR_FOLDER=\"true\">ä¹¦ç­¾æ </H3>\r\n    <DL><p>\r\n        <DT><A HREF=\"https://www.example.com\" ADD_DATE=\"1634454300\" ICON=\"data:image/png;base64,...\" LAST_MODIFIED=\"1634454320\">ç¤ºä¾‹ç½‘ç«™</A>\r\n        <!-- æ›´å¤šä¹¦ç­¾... -->\r\n    </DL><p>\r\n</DL><p>\r\n```\r\n\r\n### æ ¸å¿ƒæ ‡ç­¾è§£æ\r\n\r\nä¹¦ç­¾æ–‡ä»¶ä½¿ç”¨ä»¥ä¸‹å‡ ä¸ªå…³é”® `HTML` æ ‡ç­¾æ¥ç»„ç»‡æ•°æ®ï¼š\r\n\r\n- `<DL>`ï¼šå®šä¹‰ä¹¦ç­¾åˆ—è¡¨çš„å®¹å™¨æ ‡ç­¾\r\n- `<DT>`ï¼šæ¯ä¸ªä¹¦ç­¾æ¡ç›®çš„æ ‡ç­¾\r\n- `<H3>`ï¼šç”¨äºæ ‡è¯†ä¹¦ç­¾æ–‡ä»¶å¤¹çš„æ ‡é¢˜\r\n- `<A>`ï¼šå­˜å‚¨å…·ä½“ä¹¦ç­¾ä¿¡æ¯ï¼ŒåŒ…å« `URL`ã€åç§°ç­‰å±æ€§\r\n\r\næ¯ä¸ªæ ‡ç­¾éƒ½æºå¸¦äº†ä¸°å¯Œçš„å±æ€§ä¿¡æ¯ï¼Œå¦‚æ·»åŠ æ—¶é—´ `ADD_DATE` å’Œæœ€åä¿®æ”¹æ—¶é—´ `LAST_MODIFIED` ç­‰ã€‚\r\n\r\n## ä¹¦ç­¾æ–‡ä»¶è§£ææµç¨‹\r\n\r\nè¦å°†ä¹¦ç­¾æ–‡ä»¶è½¬æ¢ä¸ºå¯ç”¨çš„æ•°æ®ç»“æ„ï¼Œéœ€è¦éµå¾ªä»¥ä¸‹æ­¥éª¤ï¼š\r\n\r\n1. æ–‡ä»¶è§£æï¼šéå† `<H3>` æ ‡ç­¾è·å–æ–‡ä»¶å¤¹ç»“æ„\r\n2. å†…å®¹æå–ï¼šè§£æ `<DL>` æ ‡ç­¾ä¸‹çš„ä¹¦ç­¾åˆ—è¡¨\r\n3. è¯¦æƒ…è·å–ï¼šå¤„ç†æ¯ä¸ª `<DT>` æ ‡ç­¾ä¸­çš„å…·ä½“ä¹¦ç­¾ä¿¡æ¯\r\n4. å±‚çº§æ„å»ºï¼šé€šè¿‡çˆ¶å­å…³ç³»å»ºç«‹å®Œæ•´çš„ç›®å½•æ ‘\r\n5. æ•°æ®è½¬æ¢ï¼šå°†è§£æç»“æœè½¬æ¢ä¸ºæ ‡å‡† `JSON` æ ¼å¼\r\n\r\nè§£æåçš„æ•°æ®ç»“æ„ç¤ºä¾‹ï¼š\r\n\r\n```json\r\n{\r\n  \"title\": \"ä¹¦ç­¾æ \",\r\n  \"bookmarks\": [\r\n    {\r\n      \"title\": \"ç¤ºä¾‹ç½‘ç«™\",\r\n      \"url\": \"https://www.example.com\",\r\n      \"addAt\": \"2021-10-17T15:05:00+08:00\",\r\n      \"updateAt\": \"2021-10-17T15:05:20+08:00\"\r\n    }\r\n  ],\r\n  \"addAt\": \"2021-10-17T15:00:00+08:00\",\r\n  \"updateAt\": \"2021-10-17T15:03:20+08:00\"\r\n}\r\n```\r\n\r\n### è§£æä¹¦ç­¾æ–‡ä»¶\r\n\r\n```go\r\n// parseBookmarks extracts bookmarks from the goquery document and returns a slice of bookmark entries.\r\nfunc parseBookmarks(doc *goquery.Document) []Bookmark {\r\n    // initialize a map to store bookmarks with their titles as keys.\r\n    bookmarkMap := make(map[string]*Bookmark)\r\n\r\n    // helper function to parse timestamp.\r\n    parseTime := func(timestamp string) *time.Time {\r\n        if len(timestamp) == 0 {\r\n            return nil\r\n        }\r\n        ts, err := strconv.ParseInt(timestamp, 10, 64)\r\n        if err != nil {\r\n            fmt.Println(\"error parsing timestamp:\", err.Error())\r\n            return nil\r\n        }\r\n        t := time.Unix(ts, 0)\r\n        return &t\r\n    }\r\n\r\n    // iterate over each H3 element in the document representing bookmark titles.\r\n    doc.Find(\"H3\").Each(func(i int, header *goquery.Selection) {\r\n        // create a bookmark entry for the current H3 element.\r\n        bookmark := Bookmark{\r\n            Title:    header.Text(),\r\n            AddAt:    parseTime(header.AttrOr(\"add_date\", \"\")),\r\n            UpdateAt: parseTime(header.AttrOr(\"last_modified\", \"\")),\r\n        }\r\n\r\n        // check if the header has a sibling DL element containing bookmarks.\r\n        if dlNode := header.Next(); dlNode.Is(\"DL\") {\r\n            // iterate over each DT element representing sub-bookmark titles.\r\n            dlNode.ChildrenFiltered(\"DT\").Each(func(j int, dtNode *goquery.Selection) {\r\n                if aNode := dtNode.Children().First(); aNode.Is(\"A\") {\r\n                    // create a bookmark entry for each bookmark within the DL element.\r\n                    subBookmark := Bookmark{\r\n                        Title:    aNode.Text(),\r\n                        URL:      aNode.AttrOr(\"href\", \"\"),\r\n                        AddAt:    parseTime(aNode.AttrOr(\"add_date\", \"\")),\r\n                        UpdateAt: parseTime(aNode.AttrOr(\"last_modified\", \"\")),\r\n                    }\r\n                    bookmark.Bookmarks = append(bookmark.Bookmarks, subBookmark)\r\n                }\r\n            })\r\n        }\r\n\r\n        // check if the bookmark has a parent folder (H3 element).\r\n        if parentDL := header.Parent().Parent(); parentDL.Is(\"DL\") && parentDL.Prev().Is(\"H3\") {\r\n            // set the parent field for the current bookmark.\r\n            bookmark.Parent = parentDL.Prev().Text()\r\n        }\r\n\r\n        // add the bookmark to the map.\r\n        bookmarkMap[bookmark.Title] = &bookmark\r\n    })\r\n\r\n    // convert the map values to a slice and return.\r\n    bookmarks := make([]Bookmark, 0, len(bookmarkMap))\r\n    for _, bookmark := range bookmarkMap {\r\n        bookmarks = append(bookmarks, *bookmark)\r\n    }\r\n    return bookmarks\r\n}\r\n```\r\n\r\n### å»ºç«‹ä¹¦ç­¾çš„ç›®å½•æ ‘ç»“æ„\r\n\r\n```go\r\n// buildTree constructs the bookmark tree by finding the root folder and building the sub-trees.\r\nfunc buildTree(bookmarks []Bookmark) Bookmark {\r\n    // function to find the root folder by looking for a bookmark without a parent.\r\n    findRootFolder := func(bookmarks []Bookmark) *Bookmark {\r\n          for i := range bookmarks {\r\n            if bookmarks[i].Parent == \"\" {\r\n                return &bookmarks[i]\r\n            }\r\n        }\r\n        return nil\r\n    }\r\n\r\n    root := findRootFolder(bookmarks)\r\n    if root == nil {\r\n        fmt.Println(\"root folder not found\")\r\n        return Bookmark{}\r\n    }\r\n\r\n    // function to build the sub-tree recursively.\r\n    var buildSubTree func(parent *Bookmark)\r\n    buildSubTree = func(parent *Bookmark) {\r\n        for i := range bookmarks {\r\n            if bookmarks[i].Parent == parent.Title {\r\n                parent.Bookmarks = append(parent.Bookmarks, bookmarks[i])\r\n                buildSubTree(&parent.Bookmarks[len(parent.Bookmarks)-1])\r\n            }\r\n        }\r\n    }\r\n\r\n    // build the sub-tree for the root folder.\r\n    buildSubTree(root)\r\n    return *root\r\n}\r\n```\r\n\r\n## ä¹¦ç­¾æ•°æ®çš„å®é™…åº”ç”¨\r\n\r\næˆåŠŸè§£æä¹¦ç­¾æ–‡ä»¶åï¼Œæ‚¨å¯ä»¥å……åˆ†å‘æŒ¥æ•°æ®çš„ä»·å€¼ï¼š\r\n\r\n1. æ™ºèƒ½åˆ†ç±»ä¸ç®¡ç†\r\n\r\n   - åŸºäºè®¿é—®é¢‘ç‡è¿›è¡Œæ’åº\r\n   - æ ¹æ®å†…å®¹ç›¸å…³æ€§è‡ªåŠ¨åˆ†ç±»\r\n   - æ¸…ç†é‡å¤å’Œå¤±æ•ˆé“¾æ¥\r\n\r\n2. æ•°æ®å¤‡ä»½ä¸è¿ç§»\r\n\r\n   - å®šæœŸè‡ªåŠ¨å¤‡ä»½é‡è¦ä¹¦ç­¾\r\n   - è·¨è®¾å¤‡æ— ç¼åŒæ­¥\r\n   - å¿«é€Ÿæ¢å¤å†å²ä¹¦ç­¾\r\n\r\n3. åä½œä¸åˆ†äº«\r\n\r\n   - å›¢é˜Ÿä¹¦ç­¾åº“å…±äº«\r\n   - ä¸ªæ€§åŒ–æ¨èç³»ç»Ÿ\r\n   - ç¤¾äº¤åŒ–ä¹¦ç­¾åˆ†äº«\r\n\r\n4. æ•°æ®åˆ†æ\r\n\r\n   - æµè§ˆä¹ æƒ¯åˆ†æ\r\n   - å…´è¶£åå¥½è¿½è¸ª\r\n   - æ—¶é—´ç®¡ç†ä¼˜åŒ–\r\n\r\n## æœ€å\r\n\r\nä¹¦ç­¾ç®¡ç†æ˜¯æå‡ç½‘ç»œä½¿ç”¨æ•ˆç‡çš„å…³é”®å·¥å…·ã€‚é€šè¿‡æ·±å…¥ç†è§£ä¹¦ç­¾æ–‡ä»¶çš„ç»“æ„å’Œè§£ææ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ„å»ºæ›´æ™ºèƒ½ã€æ›´ä¸ªæ€§åŒ–çš„ä¹¦ç­¾ç®¡ç†ç³»ç»Ÿã€‚\r\n","number":31,"labels":{"nodes":[]},"category":{"id":"DIC_kwDONzrbkM4Cmnbf","name":"Show and tell","slug":"show-and-tell","emoji":":raised_hands:","emojiHTML":"<div>ğŸ™Œ</div>"},"author":{"login":"onnttf"},"authorAssociation":"OWNER","createdAt":"2023-07-01T08:00:00Z","updatedAt":"2025-02-05T11:55:00Z","repository":{"id":"R_kgDONzrbkA","url":"https://github.com/onnttf/blog"},"url":"https://github.com/onnttf/blog/discussions/31","updatedAtTimestamp":1738756500,"jsonFilePath":"discussions/31-D_kwDONzrbkM4AeNcE.json","markdownFilePath":"2023/7/31-D_kwDONzrbkM4AeNcE.md"}
