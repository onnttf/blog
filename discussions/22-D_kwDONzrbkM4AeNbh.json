{"id":"D_kwDONzrbkM4AeNbh","title":"如何评估算法优劣","body":"评估算法的优劣，有两个关键维度需要考虑：\r\n\r\n- 时间复杂度 - 执行效率\r\n\r\n  反映算法执行所需要的时间成本，衡量程序运行快慢。\r\n\r\n- 空间复杂度 - 内存占用\r\n\r\n  反映算法执行过程中对存储空间的需求。\r\n\r\n## 如何描述算法复杂度\r\n\r\n我们通常使用 **大 O 表示法**来描述算法复杂度，它表示随着输入数据规模的增长，算法的性能变化趋势。\r\n\r\n大 O 表示法本质上是一种粗略的分析模型。它通过估算算法运行时间随输入规模的增长趋势，帮助我们评估不同算法的性能表现。虽然这种表示法并不精确，但在实际工作中非常实用，能够帮助开发者快速选择合适的算法方案。\r\n\r\n### 时间复杂度\r\n\r\n时间复杂度是评估算法运行效率的关键指标，它反映了**随着输入规模的增长，算法执行时间的变化趋势**。\r\n\r\n我们可以遵循以下三个步骤计算时间复杂度：\r\n\r\n1. 识别核心操作\r\n\r\n   找出算法中执行次数最多的基本语句，它们通常位于最内层循环中\r\n\r\n2. 建立数学模型\r\n\r\n   分析这些核心操作的执行次数与输入规模 `n` 的关系，**只保留主要影响项**\r\n\r\n3. 转化为大 O 表示法\r\n\r\n   利用大 O 符号表示最终的时间复杂度增长趋势\r\n\r\n下面通过典型例子来加深理解：\r\n\r\n- 常数时间 `O(1)`，如 `9`\r\n- 线性时间 `O(n)`，如 `2n + 3`\r\n- 平方时间 `O(n²)`，如 `n² + 2n + 3`\r\n- 立方时间 `O(n³)`，如 `4n³ + 3n² + 22n + 100`\r\n- 对数时间 `O(logn)`，如 `5log₂n + 20`\r\n- 线性对数 `O(nlogn)`，如 `2n + 3nlog₂n + 19`\r\n- 指数时间 `O(2ⁿ)`，如 `2ⁿ`\r\n\r\n#### 常见时间复杂度排序\r\n\r\n下面从最优到最差的顺序，列出了常见的时间复杂度：\r\n\r\n`O(1)` < `O(logn)` < `O(n)` < `O(nlogn)` < `O(n²)` < `O(n³)` < `O(n^k)` < `O(2^n)` < `O(n!)`\r\n\r\n随着复杂度的增加，算法的性能会急剧下降。在实际开发中，我们通常会尽量避免使用后几种复杂度较高的算法。\r\n\r\n### 空间复杂度\r\n\r\n空间复杂度是评估算法效率的另一个关键指标，它反映了**随着输入规模的增长，算法占用存储空间的变化趋势**。\r\n\r\n在分析算法的空间开销时，我们需要考虑三个主要组成部分：\r\n\r\n1. 输入空间：用于存储算法输入数据的内存空间，与问题规模直接相关\r\n2. 程序空间：存储算法代码本身所需的内存空间，通常为固定值\r\n3. 工作空间：算法运行过程中临时使用的额外内存空间，包括临时变量、递归栈等\r\n\r\n在评估空间复杂度时，我们主要关注**工作空间**的增长趋势。这是因为输入空间和程序空间通常是固定的，且由具体问题和实现决定，优化空间有限。而工作空间则直接反映了算法本身对额外内存的需求，是算法设计时最需要关注的部分。\r\n\r\n常见的空间复杂度有：\r\n\r\n1. `O(1)` - 常量空间\r\n\r\n   - 空间消耗与输入规模无关\r\n   - 只需要固定的临时变量即可完成计算\r\n   - 如简单的数值计算、遍历等\r\n\r\n2. `O(n)` - 线性空间\r\n\r\n   - 空间消耗与输入规模呈线性增长\r\n   - 需要额外的数组或链表来存储中间结果\r\n   - 如归并排序等需要辅助数组的算法\r\n\r\n3. `O(n²)` - 平方空间\r\n\r\n   - 需要二维数组这样的数据结构\r\n   - 如动态规划中的状态转移矩阵\r\n\r\n4. `O(logn)` - 对数空间\r\n\r\n   - 主要出现在递归算法中\r\n   - 如二分查找的递归实现\r\n\r\n## 如何优化算法\r\n\r\n算法优化的本质是在时间和空间复杂度之间找到最佳平衡。以下是一些常见的优化策略：\r\n\r\n1. 降低内存使用\r\n\r\n   - 及时释放闲置内存，避免内存泄漏\r\n   - 重复利用已分配的空间，减少频繁分配\r\n   - 使用合适的数据结构，避免空间浪费\r\n   - 采用原地算法，减少辅助空间\r\n\r\n2. 提升执行效率\r\n\r\n   - 选择合适的数据结构提高访问效率\r\n   - 消除重复计算，利用中间结果\r\n   - 合理使用缓存加速数据访问\r\n   - 优化循环结构，减少不必要的迭代\r\n   - 利用位运算代替乘除运算\r\n   - 避免频繁的对象创建\r\n\r\n3. 权衡取舍\r\n\r\n   - 结合具体业务场景选择合适方案\r\n   - 灵活运用\"时空互换\"策略\r\n   - 在算法复杂度和代码可读性间平衡\r\n   - 综合考虑开发成本和维护难度\r\n\r\n## 最后\r\n\r\n在实际开发中，没有完美的算法，关键是根据具体应用场景找到最合适的解决方案。\r\n\r\n- 有时为了获得更好的时间性能，可以适当增加空间开销，这就是经典的\"空间换时间\"策略\r\n- 有时也可能需要牺牲一些时间性能来节省内存使用\r\n\r\n优化时应当保持代码的可维护性，过度优化可能会带来更多问题。\r\n","number":22,"labels":{"nodes":[]},"category":{"id":"DIC_kwDONzrbkM4Cmnbf","name":"Show and tell","slug":"show-and-tell","emoji":":raised_hands:","emojiHTML":"<div>🙌</div>"},"author":{"login":"onnttf"},"authorAssociation":"OWNER","createdAt":"2020-07-22T08:00:00Z","updatedAt":"2025-02-05T11:43:53Z","repository":{"id":"R_kgDONzrbkA","url":"https://github.com/onnttf/blog"},"url":"https://github.com/onnttf/blog/discussions/22","updatedAtTimestamp":1738755833,"jsonFilePath":"discussions/22-D_kwDONzrbkM4AeNbh.json","markdownFilePath":"2020/7/22-D_kwDONzrbkM4AeNbh.md"}
