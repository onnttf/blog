{"id":"D_kwDONzrbkM4AeLcU","title":"二维码生成与美化","body":"在移动互联网时代，二维码作为信息传递的重要载体，已深度融入我们的日常生活。从移动支付、社交分享到身份验证，二维码以其快速便捷的特点，成为现代移动应用不可或缺的标配功能。\r\n\r\n本文将系统讲解如何使用 [CIQRCodeGenerator](https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CoreImageFilterReference/#//apple_ref/doc/filter/ci/CIQRCodeGenerator) 实现二维码的生成与美化。\r\n\r\n## 需求背景\r\n\r\n本文源于一个实际项目需求 - 开发类似支付宝红包的二维码分享功能。\r\n\r\n具体要求包括：\r\n\r\n1. 生成高清的二维码，确保稳定的识别效果\r\n2. 在二维码中央嵌入品牌 `logo`，提升品牌辨识度\r\n3. 支持添加精美背景图片，让二维码更具视觉吸引力\r\n4. 实现二维码颜色的灵活定制，满足不同场景的设计需求\r\n\r\n在接下来的内容中，将系统且详细地讲解实现二维码生成与美化的完整流程。\r\n\r\n## 核心功能实现\r\n\r\n在开始编码之前，我们先了解几个关键概念：\r\n\r\n- **CIQRCodeGenerator**: `CoreImage` 框架提供的原生二维码生成器\r\n- **纠错级别**: 二维码的容错能力，分为 L(7%)、M(15%)、Q(25%)、H(30%) 四个等级\r\n- **清晰度处理**: 原生生成的二维码可能模糊，需要进行优化\r\n\r\n### 生成二维码\r\n\r\n生成二维码的场景非常广泛，为了实现二维码功能的灵活复用，我们将二维码生成逻辑封装为 `UIImage` 的扩展。\r\n\r\n整个生成过程主要包含以下步骤：\r\n\r\n1. 导入 `Core Image` 框架\r\n\r\n   ```objc\r\n   #import <CoreImage/CoreImage.h>\r\n   ```\r\n\r\n2. 利用 `CIFilter` 创建二维码\r\n\r\n   ```objc\r\n   // 创建 QR Code 生成器滤镜\r\n   CIFilter *filter = [CIFilter filterWithName:@\"CIQRCodeGenerator\"];\r\n   // 将 filter 所有属性设置为默认值\r\n   [filter setDefaults];\r\n\r\n   // 将待编码的字符串转换为 UTF-8 格式的数据\r\n   NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];\r\n   [filter setValue:data forKey:@\"inputMessage\"];\r\n\r\n   // 设置二维码的纠错级别，纠错级别越高，二维码的抗损坏能力越强\r\n   // L (7%): 适用于环境较好的场景\r\n   // M (15%): 常规使用的推荐级别\r\n   // Q (25%): 适合复杂场景或需要添加 Logo\r\n   // H (30%): 对清晰度要求最高的场景\r\n   [filter setValue:@\"H\" forKey:@\"inputCorrectionLevel\"];\r\n\r\n   // 获取生成的二维码图像\r\n   CIImage *outputImage = [filter outputImage];\r\n   ```\r\n\r\n### 清晰度优化\r\n\r\n原生生成的二维码图像分辨率较低，为了获得更好的识别效果和视觉体验，我们提供两种优化方案。\r\n\r\n#### CoreGraphics 优化方案\r\n\r\n这种方案通过 `CoreGraphics` 框架对二维码图像进行重绘和缩放，能有效提升图像清晰度。\r\n\r\n```objc\r\n/**\r\n 调整二维码清晰度\r\n\r\n @param img 原始二维码图片\r\n @param size 目标二维码尺寸\r\n @return 优化后的清晰二维码图片\r\n */\r\n- (UIImage *)getHDImgWithCIImage:(CIImage *)img size:(CGSize)size {\r\n    // 计算绘制区域和缩放比例\r\n    CGRect extent = CGRectIntegral(img.extent);\r\n    CGFloat scale = MIN(size.width / CGRectGetWidth(extent), size.height / CGRectGetHeight(extent));\r\n\r\n    // 创建灰度色彩空间的位图上下文\r\n    size_t width = CGRectGetWidth(extent) * scale;\r\n    size_t height = CGRectGetHeight(extent) * scale;\r\n    CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray();\r\n    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, cs, (CGBitmapInfo)kCGImageAlphaNone);\r\n\r\n    // 将 CIImage 转换为 CGImage\r\n    CIContext *context = [CIContext contextWithOptions:nil];\r\n    CGImageRef bitmapImage = [context createCGImage:img fromRect:extent];\r\n\r\n    // 设置图像质量并执行缩放绘制\r\n    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);\r\n    CGContextScaleCTM(bitmapRef, scale, scale);\r\n    CGContextDrawImage(bitmapRef, extent, bitmapImage);\r\n\r\n    // 生成最终图像\r\n    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);\r\n\r\n    // 清理资源\r\n    CGContextRelease(bitmapRef);\r\n    CGImageRelease(bitmapImage);\r\n\r\n    // 创建并返回 UIImage\r\n    UIImage *outputImage = [UIImage imageWithCGImage:scaledImage];\r\n\r\n    // 释放图像资源\r\n    CGImageRelease(scaledImage);\r\n    CGColorSpaceRelease(cs);\r\n\r\n    return outputImage;\r\n}\r\n```\r\n\r\n#### CIFilter 优化方案\r\n\r\n这种方案通过 `CIFilter` 滤镜对二维码图像进行处理，可以有效提升图像清晰度。\r\n\r\n```objc\r\n/**\r\n 使用 CIFilter 调整二维码清晰度\r\n\r\n @param img 原始二维码图片\r\n @param size 目标二维码尺寸\r\n @return 优化后的清晰二维码图片\r\n */\r\n- (UIImage *)getHDImgWithCIFilterAndCIImage:(CIImage *)img size:(CGSize)size {\r\n    // 设置二维码颜色\r\n    UIColor *pointColor = [UIColor blackColor];\r\n    UIColor *backgroundColor = [UIColor whiteColor];\r\n\r\n    // 创建颜色滤镜\r\n    CIFilter *colorFilter = [CIFilter filterWithName:@\"CIFalseColor\"\r\n                                    keysAndValues:\r\n                            @\"inputImage\", img,\r\n                            @\"inputColor0\", [CIColor colorWithCGColor:pointColor.CGColor],\r\n                            @\"inputColor1\", [CIColor colorWithCGColor:backgroundColor.CGColor],\r\n                            nil];\r\n\r\n    CIImage *qrImage = colorFilter.outputImage;\r\n\r\n    // 绘制最终图像\r\n    CGImageRef cgImage = [[CIContext contextWithOptions:nil] createCGImage:qrImage fromRect:qrImage.extent];\r\n    UIGraphicsBeginImageContext(size);\r\n    CGContextRef context = UIGraphicsGetCurrentContext();\r\n    CGContextSetInterpolationQuality(context, kCGInterpolationNone);\r\n    CGContextScaleCTM(context, 1.0, -1.0);\r\n    CGContextDrawImage(context, CGContextGetClipBoundingBox(context), cgImage);\r\n    UIImage *codeImage = UIGraphicsGetImageFromCurrentImageContext();\r\n    UIGraphicsEndImageContext();\r\n\r\n    CGImageRelease(cgImage);\r\n\r\n    return codeImage;\r\n}\r\n```\r\n\r\n下面这张图片展示了经过清晰度处理后的二维码，你可以发现每个像素点都清晰可见，扫描识别也更加稳定可靠。\r\n\r\n![image](https://file.onnttf.site/2017/12/15/1.jpeg)\r\n\r\n经过优化后的图像质量完全可以满足大多数实际应用场景的需求。\r\n\r\n### 美化二维码\r\n\r\n创建基础二维码后，我们可以通过多种方式对其进行美化，主要包括颜色修改、添加 `logo` 和图片拼接等功能。\r\n\r\n#### 修改二维码颜色\r\n\r\n二维码颜色修改的核心原理是遍历并修改图像的每个像素点。我们通过位图上下文来处理图像数据：\r\n\r\n```objc\r\n/**\r\n 修改二维码颜色\r\n\r\n @param image 原始二维码图片\r\n @param red 红色通道值 (0-255)\r\n @param green 绿色通道值 (0-255)\r\n @param blue 蓝色通道值 (0-255)\r\n @return 修改颜色后的二维码图片\r\n */\r\n+ (UIImage *)changeColorWithQRCodeImg:(UIImage *)image\r\n                                  red:(NSUInteger)red\r\n                                green:(NSUInteger)green\r\n                                 blue:(NSUInteger)blue {\r\n    const int imageWidth = image.size.width;\r\n    const int imageHeight = image.size.height;\r\n    size_t bytesPerRow = imageWidth * 4;\r\n    uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight);\r\n\r\n    // 创建 RGB 色彩空间和位图上下文\r\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\r\n    CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast);\r\n\r\n    // 绘制原始图像到位图上下文\r\n    CGContextDrawImage(context, (CGRect){CGPointZero, image.size}, image.CGImage);\r\n\r\n    int pixelNumber = imageHeight * imageWidth;\r\n    // 修改像素颜色\r\n    [self changeColorOnPixel:rgbImageBuf pixelNum:pixelNumber red:red green:green blue:blue];\r\n\r\n    // 创建新的图像\r\n    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow, ProviderReleaseData);\r\n    CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpace, kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault);\r\n    UIImage *resultImage = [UIImage imageWithCGImage:imageRef];\r\n\r\n    // 释放资源\r\n    CGImageRelease(imageRef);\r\n    CGColorSpaceRelease(colorSpace);\r\n    CGContextRelease(context);\r\n\r\n    return resultImage;\r\n}\r\n\r\n/**\r\n 遍历并修改像素点颜色\r\n\r\n @param rgbImageBuf 像素数据缓冲区\r\n @param pixelNum 像素总数\r\n @param red 红色通道值 (0-255)\r\n @param green 绿色通道值 (0-255)\r\n @param blue 蓝色通道值 (0-255)\r\n */\r\n+ (void)changeColorOnPixel:(uint32_t *)rgbImageBuf\r\n                 pixelNum:(int)pixelNum\r\n                      red:(NSUInteger)red\r\n                   green:(NSUInteger)green\r\n                    blue:(NSUInteger)blue {\r\n    uint32_t *pCurPtr = rgbImageBuf;\r\n\r\n    for (int i = 0; i < pixelNum; i++, pCurPtr++) {\r\n        // 识别二维码的数据点\r\n        if ((*pCurPtr & 0xffffff00) < 0xd0d0d000) {\r\n            uint8_t *ptr = (uint8_t *)pCurPtr;\r\n            ptr[3] = red;\r\n            ptr[2] = green;\r\n            ptr[1] = blue;\r\n        } else {\r\n            // 将背景设为透明\r\n            uint8_t *ptr = (uint8_t *)pCurPtr;\r\n            ptr[0] = 0;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n![image](https://file.onnttf.site/2017/12/15/2.jpeg)\r\n\r\n#### 添加 logo\r\n\r\n为二维码添加 `logo` 可以提升品牌识别度。注意 `logo` 大小要适中，避免影响二维码的识别：\r\n\r\n```objc\r\n/**\r\n 为二维码添加 logo\r\n\r\n @param img 原始二维码图片\r\n @param size 目标二维码尺寸\r\n @param logoImg logo 图片\r\n @return 添加 logo 后的二维码图片\r\n */\r\n- (UIImage *)getHDImgWithCIImage:(CIImage *)img\r\n                            size:(CGSize)size\r\n                         logoImg:(UIImage *)logoImg {\r\n    // 计算二维码缩放比例\r\n    CGRect extent = CGRectIntegral(img.extent);\r\n    CGFloat scale = MIN(size.width / CGRectGetWidth(extent), size.height / CGRectGetHeight(extent));\r\n\r\n    // 创建位图上下文\r\n    size_t width = CGRectGetWidth(extent) * scale;\r\n    size_t height = CGRectGetHeight(extent) * scale;\r\n    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceGray();\r\n    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaNone);\r\n\r\n    // 绘制二维码图像到上下文\r\n    CIContext *context = [CIContext contextWithOptions:nil];\r\n    CGImageRef bitmapImage = [context createCGImage:img fromRect:extent];\r\n    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);\r\n    CGContextScaleCTM(bitmapRef, scale, scale);\r\n    CGContextDrawImage(bitmapRef, extent, bitmapImage);\r\n\r\n    // 生成二维码图像\r\n    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);\r\n    UIImage *outputImage = [UIImage imageWithCGImage:scaledImage];\r\n\r\n    // 开始绘制 logo\r\n    UIGraphicsBeginImageContextWithOptions(outputImage.size, NO, [[UIScreen mainScreen] scale]);\r\n    [outputImage drawInRect:CGRectMake(0, 0, size.width, size.height)];\r\n    // logo 居中绘制\r\n    [logoImg drawInRect:CGRectMake((size.width - logoImg.size.width) / 2.0,\r\n                                   (size.height - logoImg.size.height) / 2.0,\r\n                                   logoImg.size.width,\r\n                                   logoImg.size.height)];\r\n    UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext();\r\n    UIGraphicsEndImageContext();\r\n\r\n    // 清理资源\r\n    CGContextRelease(bitmapRef);\r\n    CGImageRelease(bitmapImage);\r\n    CGImageRelease(scaledImage);\r\n    CGColorSpaceRelease(colorSpace);\r\n\r\n    return newPic;\r\n}\r\n```\r\n\r\n#### 拼接图片\r\n\r\n我们还可以将二维码与其他图片灵活拼接，从而实现更丰富的视觉效果。\r\n\r\n下面的代码演示了如何将二维码与其他图片按照指定位置组合在一起：\r\n\r\n```objc\r\n/**\r\n 拼接两张图片\r\n\r\n @param img1 底图\r\n @param img2 上层图片\r\n @param location 上层图片相对于底图的位置\r\n @return 拼接后的图片\r\n */\r\n+ (UIImage *)spliceImg1:(UIImage *)img1\r\n                   img2:(UIImage *)img2\r\n          img2Location:(CGPoint)location {\r\n    CGSize img2Size = img2.size;\r\n\r\n    // 创建绘图上下文\r\n    UIGraphicsBeginImageContextWithOptions(img1.size, NO, [[UIScreen mainScreen] scale]);\r\n\r\n    // 绘制底图\r\n    [img1 drawInRect:CGRectMake(0, 0, img1.size.width, img1.size.height)];\r\n\r\n    // 在指定位置绘制上层图片\r\n    [img2 drawInRect:CGRectMake(location.x, location.y, img2Size.width, img2Size.height)];\r\n\r\n    // 获取最终拼接后的图片\r\n    UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext();\r\n    UIGraphicsEndImageContext();\r\n\r\n    return newPic;\r\n}\r\n```\r\n\r\n下图展示了二维码与图片素材拼接后的效果。\r\n\r\n![image](https://file.onnttf.site/2017/12/15/3.jpeg)\r\n\r\n通过这种灵活的组合方式，我们不仅保持了二维码的功能性，还大大提升了其视觉表现力和品牌辨识度。\r\n\r\n在实际应用中，你可以通过以下方式进一步优化拼接效果：\r\n\r\n- 调整图片尺寸比例，确保视觉重点突出\r\n- 精心设计图片位置，打造合理的视觉层次\r\n- 选择合适的背景图片，提升整体美感\r\n- 注意保持二维码识别区域的清晰度\r\n\r\n## 最后\r\n\r\n本文详细介绍了如何使用苹果原生框架实现二维码的生成和美化，希望这些内容对你的工作有所帮助。\r\n","number":6,"labels":{"nodes":[{"id":"LA_kwDONzrbkM8AAAAB4nYwyw","name":"iOS","url":"https://github.com/onnttf/blog/labels/iOS"}]},"category":{"id":"DIC_kwDONzrbkM4Cmnbf","name":"Show and tell","slug":"show-and-tell","emoji":":raised_hands:","emojiHTML":"<div>🙌</div>"},"author":{"login":"onnttf"},"authorAssociation":"OWNER","createdAt":"2017-12-15T08:00:00Z","updatedAt":"2025-02-03T15:30:57Z","repository":{"id":"R_kgDONzrbkA","url":"https://github.com/onnttf/blog"},"url":"https://github.com/onnttf/blog/discussions/6","jsonFilePath":"discussions/6-D_kwDONzrbkM4AeLcU.json","markdownFilePath":"2017/12/6-D_kwDONzrbkM4AeLcU.md"}
