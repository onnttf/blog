name: Backup Discussion

on:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  backup:
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      OWNER: ${{ github.repository_owner }}
      REPO: ${{ github.event.repository.name }}

    steps:
      - name: Checkout discussion.json
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            discussion.json
          sparse-checkout-cone-mode: false

      - name: Fetch, process, and save discussions
        run: |
          echo "Fetching discussions from GitHub API..."

          discussions=$(gh api graphql --paginate --slurp -f query='
            query($owner: String!, $repo: String!, $endCursor: String) {
              repository(owner: $owner, name: $repo) {
                discussions(first: 100, after: $endCursor) {
                  nodes {
                    id
                    title
                    body
                    number
                    labels(first: 10) { nodes { id name url } }
                    category { id name slug emoji emojiHTML }
                    author { login }
                    authorAssociation
                    createdAt
                    updatedAt
                    repository { id url }
                    url
                  }
                  pageInfo {
                    hasNextPage
                    endCursor
                  }
                }
              }
            }' -F owner=$OWNER -F repo=$REPO | jq '
            [.[].data.repository.discussions.nodes[]]
            | map(select(.authorAssociation == "OWNER"))
            | map(select(.category.slug == "announcements" or .category.slug == "show-and-tell"))
            | sort_by(.updatedAt) | reverse
            | unique_by(.id)
            // []'
          )

          num_discussions=$(echo "$discussions" | jq length)
          echo "Fetched $num_discussions discussions"

          if [ "$num_discussions" -eq 0 ]; then
            echo "No discussions found, exiting..."
            exit 1
          fi

          # Merge with existing data if discussion.json exists
          if [ -f "discussion.json" ]; then
            echo "Merging with existing discussions..."

            createdAtMap=$(jq 'map({(.id): .createdAt}) | add' "discussion.json")
            discussions=$(jq --argjson createdAtMap "$createdAtMap" '
              map(
                if $createdAtMap[.id] then
                  .createdAt = $createdAtMap[.id]
                else
                  .
                end
              )
            ' <<< "$discussions")

            echo "Merged existing data"
          fi

          # Add file paths to discussions
          discussions=$(echo "$discussions" | jq '
            map(
              . + {
                jsonFilePath: ("discussions/" + (.number | tostring) + "-" + (.id | tostring) + ".json"),
                markdownFilePath: (
                  if .category.slug == "announcements" then
                    "announcements/" + (.number | tostring) + "-" + (.id | tostring) + ".md"
                  else
                    (.createdAt | fromdate | strftime("%Y")) + "/" +
                    ((.createdAt | fromdate | strftime("%m") | tonumber) | tostring) + "/" +
                    (.number | tostring) + "-" + (.id | tostring) + ".md"
                  end
                )
              }
            )
          ')

          # Calculate the MD5 hash of the original discussion.json (before processing)
          if [ -f "discussion.json" ]; then
            original_md5=$(md5sum discussion.json | awk '{ print $1 }')
          else
            original_md5=""
          fi

          # Save the processed discussions to the file
          echo "$discussions" > discussion.json
          echo "Backup completed, saved discussions to discussion.json"

          # Calculate the MD5 hash after processing and saving the new content
          new_md5=$(md5sum discussion.json | awk '{ print $1 }')

          # Compare the original and new MD5 hashes to check if the file changed
          if [ "$original_md5" == "$new_md5" ]; then
            echo "discussion.json has not changed. Exiting job."
            exit 0
          else
            echo "discussion.json has changed"
          fi

          # 1. Traverse discussions and write to JSON and Markdown files
          echo "Writing discussions to individual files..."
          markdown_file_paths=() # Array to hold paths of markdown files for later use
          jq -c '.[]' <<< "$discussions" | while read -r discussion; do
            # Extract variables
            jsonFilePath=$(echo "$discussion" | jq -r '.jsonFilePath')
            markdownFilePath=$(echo "$discussion" | jq -r '.markdownFilePath')
            title=$(echo "$discussion" | jq -r '.title')
            body=$(echo "$discussion" | jq -r '.body')

            # 2. Write discussion data to individual JSON file
            mkdir -p $(dirname "$jsonFilePath")
            echo "$discussion" > "$jsonFilePath"
            echo "Written discussion to $jsonFilePath"

            # 3. Write Markdown content to the respective Markdown file
            mkdir -p $(dirname "$markdownFilePath")

            # Use printf to write markdown content more reliably
            printf "# %s\n\n%s\n" "$title" "$body" > "$markdownFilePath"
            echo "Written markdown to $markdownFilePath"
            # Add markdown file path to array for later use
            markdown_file_paths+=("$markdownFilePath")
          done

          echo "Markdown file paths array: ${markdown_file_paths[@]}"
          echo "Number of markdown files: ${#markdown_file_paths[@]}"


          # Randomly select one of the markdown file paths using shuf
          random_markdown_file=$(echo "${markdown_file_paths[@]}" | tr ' ' '\n' | shuf -n 1)

          echo "Displaying content of: $random_markdown_file"
          cat "$random_markdown_file"

      - name: Verify saved discussions
        run: |
          echo "Displaying contents of discussion.json:"
          ls -R
          # cat discussion.json
